import os
import signal
from threading import Lock
from typing import Iterable, Tuple, Optional

from plumbum import local, commands
from util.config import Config, ConfigField
from util.symver import SymVer
from worker.executor import Executor, ExecutionEnded


class ShellExecutorConfig(Config):
    # If work_dir is not set, then it will be autogenerated
    work_dir = ConfigField(type=str, required=False, default='')
    shell_bin = ConfigField(type=str, required=True, default='bash')
    shell_args = ConfigField(type=list, required=False, default=[])
    shell_script = ConfigField(type=str, required=True, default='exit 1')


class NoCommandRunningError(Exception):
    pass


class ExecutionDataDirAlreadyExists(Exception):
    pass


class ShellExecutor(Executor):
    name = 'shell'
    version = SymVer(0, 0, 1)
    config_class = ShellExecutorConfig

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._should_be_killed = False
        self._run_lock = Lock()
        self._subproc = None
        if not self.config.work_dir:
            self.config.work_dir = self.default_working_dir
        if os.path.exists(self.config.work_dir):
            raise ExecutionDataDirAlreadyExists(self.config.work_dir)
        os.makedirs(self.config.work_dir)
        with open(self.script_path, 'x') as script_file:
            script_file.write(self.config.shell_script)
            script_file.flush()

    @property
    def script_path(self):
        return os.path.join(self.config.work_dir, 'script')

    def start(self) -> Iterable[Tuple[Optional[str], Optional[str]]]:
        with self._run_lock:
            if self._should_be_killed:
                return ()
            if not self._subproc:
                cmd = local[self.config.shell_bin]
                for _ in self.config.shell_args:
                    cmd = cmd[_]
                cmd = cmd[self.script_path]
                self._subproc = cmd.popen(cwd=self.config.work_dir)
            return self.iterate_log(self._subproc)

    def ping(self):
        if self._subproc:
            return self._subproc.poll()
        else:
            raise NoCommandRunningError()

    def kill(self, sig: int = signal.SIGTERM):
        with self._run_lock:
            self._should_be_killed = True
            if self._subproc is not None:
                self._subproc.send_signal(sig=sig)

    @staticmethod
    def iterate_log(popen_object):
        retcode = 0
        try:
            yield from popen_object.iter_lines()
        except commands.processes.ProcessExecutionError as ex:
            retcode = ex.retcode
        raise ExecutionEnded(retcode=retcode)


if __name__ == '__main__':
    executor = ShellExecutor(
        execution_id='123',
        execution_data_root='/tmp',
        execution_config={
            'shell_bin': 'bash',
            'shell_script': '''
                echo $(date);
                sleep 1;
                echo $(date);
                sleep 1;
                echo $(date) >> /dev/stderr;
                sleep 1;
                echo $(date) >> /dev/stderr;
                sleep 1;
                exit 0;
            '''
        })
    for _ in executor.start():
        print(_)
